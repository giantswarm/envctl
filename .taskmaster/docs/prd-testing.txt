# Product Requirements Document: `envctl` Testing & Hardening

**Author:** Timo Derstappen
**Version:** 2.0
**Date:** 2025-06-16
**Status:** Draft

---

## 1. Vision & Mission

**Vision:** To build a supremely reliable, robust, and correct operational engine.

**Mission:** To systematically validate, test, and harden every component of the `envctl` engine by defining a comprehensive test suite based on real-world use cases. This effort will identify and eliminate bugs, ensure the correctness of the concepts (`Workflows`, `ServiceClasses`, `Services`, `Capabilities`, `MCPServers`), and produce a stable foundation for all future platform development.

---

## 2. Problem Statement & Goals

The `envctl` engine and its components are powerful but have exhibited stability issues in the past. To build a trusted platform on top of this engine, we must have a high degree of confidence in its correctness and reliability. Ad-hoc testing is insufficient.

**Goals:**

*   **Goal 1: Analyze the concepts:** Identify all functionality of `envctl` core, particularly the `Workflow`, `ServiceClasses`, `Services`, `Capabilities` and `MCPServers` concepts. Write down behavioral test specs.
*   **Goal 2: Analyze the code:** Identify testability of the packages in the `envctl` core, particularly the `Workflow`, `ServiceClasses`, `Services`, `Capabilities` and `MCPServers` packages. Write a PRD how to make the code testable. Parse the PRD measure complexity and expand the tasks.
*   **Goal 3: Create a Comprehensive Test Suite:** Create an automated test suite that can run the behavioral test specs to prevent regressions and validate changes. This test suite is a seperate command of envctl that executes end-to-end tests via a MCP client to the aggregated MCP server.
*   **Goal 4: Improve Debuggability:** Enhance the error reporting and logging within `envctl serve` to make diagnosing failures easier with the new test suite.
*   **Goal 5: Validate the Envctl Concepts:** Write integration tests based on the behavioral test spec.
*   **Goal 6: Achieve Foundational Stability:** Identify and fix critical bugs in the `envctl` core, particularly within the `Workflow`, `ServiceClasses`, `Services`, `Capabilities` and `MCPServers` execution lifecycle.

---

## 3. Core Concepts Analysis

Based on deep code analysis, envctl operates on five fundamental concepts that form the architecture:

### 3.1 MCPServers
**Definition:** External processes that expose tools via the Model Context Protocol (MCP).

**Architecture:**
- **Package:** `internal/mcpserver`
- **Key Components:** 
  - `MCPServerManager`: Loads and manages server definitions from YAML
  - `StdioClient`: Handles communication with local command servers
  - Container support for containerized MCP servers
- **Lifecycle:** Load definitions → Start processes → Monitor health → Handle failures
- **Configuration:** YAML-based definitions supporting both `localCommand` and `container` types
- **State Management:** Process state tracking with discrete status updates

**Current Test Coverage:** Unit tests for manager, loader, and client components. Integration tests missing.

### 3.2 Services
**Definition:** Runtime instances managed by the orchestrator with lifecycle and dependency management.

**Architecture:**
- **Package:** `internal/services`
- **Key Components:**
  - `ServiceRegistry`: Central registry for all services
  - `BaseService`: Common lifecycle management
  - `GenericServiceInstance`: Dynamic ServiceClass-based instances
- **States:** Unknown → Waiting → Starting → Running → Stopping → Stopped/Failed
- **Health:** Unknown → Checking → Healthy/Unhealthy
- **Integration:** API Service Locator Pattern with central registry
- **Service Lifecycle Operations:**
  - `core_service_start <label>`: Start a specific service
  - `core_service_stop <label>`: Stop a specific service  
  - `core_service_restart <label>`: Restart a specific service
  - `core_service_list`: List all services with state and health
  - `core_service_status <label>`: Get detailed service status
- **ServiceClass Instance Management:**
  - `core_service_create`: Create service instances from ServiceClass definitions
  - `core_service_delete`: Remove ServiceClass-based instances
  - `core_service_get`: Get detailed service instance information
- **Service Coordination Features:**
  - **Registry:** Static services and service instances are managed through the registry
  - **Dependency Management:** Complex dependency chains across service types
  - **State Synchronization:** Real-time state and health monitoring
  - **Event Streaming:** Service state change notifications via subscription channels (not exposed via mcp)

**Current Test Coverage:** Unit tests for registry and base service. Missing integration tests for state transitions.

### 3.3 ServiceClasses
**Definition:** YAML-based templates defining how to create and manage dynamic service instances.

**Architecture:**
- **Package:** `internal/serviceclass`
- **Key Components:**
  - `ServiceClassManager`: Loads and validates ServiceClass definitions
  - Template variable support for dynamic parameter mapping
  - Lifecycle tool mappings (start/stop/health/status)
- **Configuration:** YAML definitions with parameter validation and tool mappings
- **Integration:** Tool availability checking and response mapping

**Current Test Coverage:** Good unit test coverage with integration tests. Missing behavioral validation.

### 3.4 Capabilities
**Definition:** Operation definitions with embedded workflows and tool requirements.

**Architecture:**
- **Package:** `internal/capability`
- **Key Components:**
  - `CapabilityManager`: Loads capability definitions
  - `Registry`: Manages capability registration and discovery
  - `Resolver`: Resolves capability requirements to providers
- **Workflow Integration:** Embedded workflows for complex operations
- **Tool Requirements:** Dependency checking and validation

**Current Test Coverage:** Unit tests for registry and resolver. Missing integration tests for workflow execution.

### 3.5 Workflows
**Definition:** Sequences of MCP tool calls with parameter templating and result chaining.

**Architecture:**
- **Package:** `internal/workflow`
- **Key Components:**
  - `WorkflowManager`: Loads and manages workflow definitions
  - `WorkflowExecutor`: Executes workflow steps with templating
- **Features:** Input validation, template variable resolution, step result chaining
- **Schema Support:** JSON Schema validation for input parameters

**Current Test Coverage:** Good unit test coverage. Missing integration tests for complex workflow scenarios.

### 3.6 Orchestrator
**Definition:** Central coordinator managing service lifecycle, dependencies, and ServiceClass instantiation.

**Architecture:**
- **Package:** `internal/orchestrator`
- **Key Features:**
  - Unified service registry for static and dynamic services
  - ServiceClass-based service instantiation
  - Dependency management and state coordination
  - Persistence support for service definitions

**Current Test Coverage:** Basic unit tests. Missing comprehensive integration tests.

---

## 4. MCP Tool Exposure Architecture

All core concepts are exposed as MCP tools through the aggregator's dynamic tool generation system, enabling comprehensive API-driven testing and automation.

### 4.1 Tool Generation Framework

**Core Mechanism:**
- Each concept implements the `ToolProvider` interface with `GetTools()` method
- The aggregator automatically discovers and registers all tools from providers
- Tools are dynamically generated with proper schemas and handlers
- Tool names are prefixed based on function and provider type

### 4.2 Tool Categories and Naming

#### 4.2.1 Management Tools (core_ prefix)
**Purpose:** Configuration and definition management for all core concepts

**Service Management:**
- `core_service_create/update/delete`: Service instance lifecycle
- `core_service_list`: List all services with status
- `core_service_start/stop/restart`: Service lifecycle control
- `core_service_status`: Detailed service information

**ServiceClass Management:**
- `core_serviceclass_list`: List ServiceClass definitions
- `core_serviceclass_get`: Get specific ServiceClass details
- `core_serviceclass_available`: Check ServiceClass availability

**Workflow Management:**
- `core_workflow_list`: List workflow definitions
- `core_workflow_get`: Get workflow details
- `core_workflow_create/update/delete`: Workflow lifecycle
- `core_workflow_validate`: Validate workflow YAML

**Capability Management:**
- `core_capability_list`: List capability definitions
- `core_capability_get`: Get capability details
- `core_capability_load/refresh`: Capability definition management

**MCPServer Management:**
- `core_mcpserver_list`: List MCP server definitions
- `core_mcpserver_get`: Get MCP server details
- `core_mcpserver_available`: Check server availability

#### 4.2.2 Execution Tools (workflow_ and api_ prefixes)
**Purpose:** Runtime operations and workflow execution

**Workflow Execution:**
- `workflow_<name>`: Execute specific workflows (transformed from `action_` tools)
- Dynamic tool generation from workflow definitions
- Parameter validation and schema enforcement

**Capability Operations:**
- `api_<operation>`: Execute capability operations
- Direct capability tool exposure (e.g., `api_auth_login`, `api_cluster_connect`)
- Tool requirement validation before execution

#### 4.2.3 External Tools (x_ prefix)
**Purpose:** Tools from external MCP servers

**External MCP Server Tools:**
- `x_<toolname>`: Tools from external MCP servers (e.g., `x_kubernetes_get`)
- Configurable prefix system (default: `x_`)
- Dynamic tool registration and availability checking

### 4.3 Tool Discovery and Registration

**Automatic Discovery:**
1. Aggregator queries all registered API handlers for `ToolProvider` interface
2. Each provider returns `ToolMetadata` array with tool specifications
3. Tools are registered with appropriate prefixes and schemas
4. Tool availability is checked against dependencies

**Dynamic Updates:**
- Tools are refreshed when providers update their offerings
- Tool availability changes based on dependency status
- Registry updates are monitored for real-time tool availability

### 4.4 End-to-End Tool Integration

**Testing Implications:**
- All core functionality accessible via MCP tools
- Comprehensive API coverage for automated testing
- Consistent tool naming and parameter schemas
- Built-in availability and dependency checking

**Tool Execution Flow:**
1. Client calls MCP tool via aggregator
2. Aggregator routes to appropriate provider
3. Provider validates parameters and dependencies
4. Provider executes operation via internal logic
5. Results returned with standardized response format

---

## 5. Current Testing Landscape Analysis

### 5.1 Existing Test Patterns
- **Unit Tests:** Good coverage for individual components
- **Integration Tests:** Limited, focusing on configuration loading
- **TUI Tests:** Golden file snapshots for UI consistency
- **MCP Debug Tools:** Manual debugging via `mcp-debug` tools

### 5.2 Testing Gaps Identified
1. **End-to-End Behavioral Tests:** Missing comprehensive workflows testing all concepts together
2. **ServiceClass Lifecycle Testing:** Limited testing of complete instantiation workflows
3. **Error Scenario Coverage:** Insufficient testing of failure modes and recovery
4. **Performance and Load Testing:** No stress testing of concurrent operations
5. **Tool Integration Testing:** Limited testing of MCP tool interactions
6. **Orchestrator Service Coordination:** Missing tests for complex service dependency scenarios
7. **Tool Discovery and Registration:** No automated testing of tool generation and availability

### 5.3 Current Debugging Infrastructure
- **MCP Debug Tools:** Comprehensive set of debugging tools via `mcp-debug`
- **Systematic Workflow:** 5-phase debugging process documented
- **Service Health Monitoring:** Real-time health and state tracking
- **Logging Infrastructure:** Structured logging with different levels

---

## 6. Technical Architecture for Testing

### 6.1 Test Suite Architecture
**Command:** `envctl test`

**Core Components:**
1. **Test Runner Engine:** Orchestrates test execution and reporting
2. **MCP Client Integration:** Uses MCP protocol to test the running aggregator
3. **Behavioral Test Framework:** Supports BDD-style test specifications
4. **Mock Infrastructure:** Provides controllable test environments
5. **Assertion Framework:** Validates expected behaviors and states

### 6.2 Test Categories

#### 6.2.1 Behavioral Tests
- **ServiceClass Lifecycle:** Complete instantiation, start, stop, and cleanup
- **Workflow Execution:** Multi-step workflows with parameter templating
- **Capability Resolution:** Tool requirement resolution and execution
- **Service Dependencies:** Dependency chain validation and failure propagation
- **Error Handling:** Graceful failure scenarios and recovery
- **Tool Discovery:** Automatic tool registration and availability checking

#### 6.2.2 Integration Tests  
- **MCP Server Health:** Server startup, failure, and recovery scenarios
- **Tool Availability:** Dynamic tool registration and availability checking
- **State Consistency:** Service state synchronization across components
- **Configuration Loading:** YAML definition loading and validation
- **Persistence:** Service definition persistence and restoration
- **Orchestrator Coordination:** Service dependency and state management

#### 6.2.3 Load & Performance Tests
- **Concurrent Operations:** Multiple ServiceClass instantiations
- **Resource Limits:** Memory and CPU usage under load
- **Tool Call Throughput:** MCP tool execution performance
- **State Change Propagation:** Event processing performance

### 6.3 Test Data Management
- **Fixtures:** Pre-defined test configurations and scenarios
- **Mock Services:** Controllable service implementations for testing
- **Test Isolation:** Each test runs in isolated environment
- **Cleanup Automation:** Automatic resource cleanup after tests

---

## 7. Development Roadmap

### 7.1 Phase 1: Foundation & Analysis
**MVP Requirements:**
- Complete behavioral specification for all core concepts
- Testability analysis of existing codebase
- Test framework architecture design
- Basic test runner implementation

**Deliverables:**
- Behavioral test specifications document
- Testability gap analysis report
- Test framework design document
- `envctl test` command skeleton

### 7.2 Phase 2: Core Test Infrastructure
**Requirements:**
- Implement test runner with MCP client integration
- Create mock infrastructure for controlled testing
- Develop assertion framework for state validation
- Build test data fixtures and scenarios

**Deliverables:**
- Functional `envctl test` command
- Mock MCP servers and services
- Test fixture library
- Basic behavioral test suite

### 7.3 Phase 3: Comprehensive Test Coverage
**Requirements:**
- Implement all behavioral test scenarios
- Add integration tests for component interactions
- Create load and performance test suites
- Enhance debugging and error reporting

**Deliverables:**
- Complete behavioral test coverage
- Integration test suite
- Performance test benchmarks
- Enhanced debugging capabilities

### 7.4 Phase 4: Validation & Hardening
**Requirements:**
- Execute comprehensive test suite against current codebase
- Identify and fix discovered bugs
- Optimize performance based on test results
- Create documentation and runbooks

**Deliverables:**
- Bug fixes and stability improvements
- Performance optimizations
- Testing documentation
- Operational runbooks

---

## 8. Logical Dependency Chain

### 8.1 Foundation Layer
1. **Behavioral Specifications:** Define expected behaviors for all concepts
2. **Test Framework:** Build the testing infrastructure
3. **Mock Infrastructure:** Create controllable test environment

### 8.2 Implementation Layer
4. **MCPServer Tests:** Validate server lifecycle and tool exposure
5. **Service Tests:** Test service registry and lifecycle management
6. **ServiceClass Tests:** Validate template processing and instantiation

### 8.3 Integration Layer
7. **Capability Tests:** Test operation execution and workflow integration
8. **Workflow Tests:** Validate multi-step execution and templating
9. **Orchestrator Tests:** Test service coordination and dependency management

### 8.4 Validation Layer
10. **End-to-End Tests:** Complete system validation scenarios
11. **Performance Tests:** Load testing and resource optimization
12. **Error Scenario Tests:** Failure mode validation and recovery

---

## 9. User Experience

### 9.1 Developer Experience
**Test Execution:**
```bash
# Run all tests
envctl test

# Run specific test category
envctl test --category=behavioral
envctl test --category=integration
envctl test --category=performance

# Run tests for specific concepts
envctl test --concept=serviceclass
envctl test --concept=workflow

# Run with detailed output
envctl test --verbose --debug
```

**Test Development:**
- YAML-based test specifications for easy maintenance
- Template support for parameterized test scenarios
- Integration with existing `mcp-debug` tools for manual validation

### 9.2 Test Output and Reporting
- **Real-time Progress:** Live test execution feedback
- **Detailed Reports:** Comprehensive test results with timings
- **Failure Analysis:** Detailed error information and suggested fixes
- **Performance Metrics:** Resource usage and timing information

---

## 10. Risks and Mitigations

### 10.1 Technical Challenges
**Risk:** Complex integration testing across multiple concepts
**Mitigation:** Incremental implementation with isolation between test categories

**Risk:** Test environment stability and reproducibility
**Mitigation:** Comprehensive mock infrastructure and test isolation

**Risk:** Performance impact of comprehensive testing
**Mitigation:** Optimized test execution and parallel test running

### 10.2 Resource Constraints
**Risk:** Test suite execution time affecting development velocity
**Mitigation:** Tiered testing approach with fast/slow test categories

**Risk:** Maintenance overhead of extensive test suite
**Mitigation:** Automated test generation and template-based specifications

### 10.3 Implementation Risks
**Risk:** Discovering fundamental architectural issues during testing
**Mitigation:** Incremental validation with early architectural review

**Risk:** Test suite becoming outdated as codebase evolves
**Mitigation:** Integration with CI/CD pipeline and automated validation

---

## 11. Success Metrics

### 11.1 Quality Metrics
- **Test Coverage:** >90% coverage for all core concepts
- **Bug Detection:** Identify and fix critical stability issues
- **Regression Prevention:** Zero regression failures in CI/CD

### 11.2 Performance Metrics
- **Test Execution Time:** Complete suite runs in <10 minutes
- **Resource Usage:** Tests run efficiently within resource constraints
- **Reliability:** >99% test suite reliability and consistency

### 11.3 Developer Experience Metrics
- **Time to Debug:** Reduced debugging time with enhanced tooling
- **Development Velocity:** Faster development with reliable test feedback
- **Documentation Quality:** Comprehensive testing documentation and guides

---

## 12. Appendix

### 12.1 Current Architecture Patterns
- **API Service Locator Pattern:** Central API layer for inter-package communication
- **Dependency Injection:** ToolCaller and other interfaces injected at runtime
- **State Management:** Consistent state tracking across all service types
- **Configuration-Driven:** YAML-based definitions for all dynamic components

### 12.2 Existing Debug Infrastructure
- **5-Phase Debugging Workflow:** Systematic approach to issue resolution
- **MCP Debug Tools:** Comprehensive set of debugging commands
- **Health Monitoring:** Real-time service health and state tracking
- **Structured Logging:** Detailed logging with appropriate levels

### 12.3 Testing Standards
- **Minimum Coverage:** 80% unit test coverage for new code
- **TUI Golden Files:** Snapshot testing for UI components
- **Code Formatting:** Automated formatting with `goimports` and `go fmt`
- **Integration Requirements:** All new features require integration tests