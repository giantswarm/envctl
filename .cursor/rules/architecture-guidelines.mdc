---
description: 
globs: 
alwaysApply: false
---
# Architecture Guidelines

## API Pattern (CRITICAL)

The codebase follows a **strict API pattern** for inter-package communication to avoid direct coupling:

### 1. Handler Interfaces
Define interfaces in `internal/api/handlers.go`:
```go
// Example handler interface
type CapabilityHandler interface {
    ExecuteCapability(ctx context.Context, capabilityType, operation string, params map[string]interface{}) (*mcp.CallToolResult, error)
    IsCapabilityAvailable(capabilityType, operation string) bool
    ListCapabilities() []CapabilityInfo
}
```

### 2. Adapter Implementation
Create adapters that implement the interface:
```go
// In internal/capability/api_adapter.go
type CapabilityAdapter struct {
    loader *CapabilityLoader
}

func (c *CapabilityAdapter) ExecuteCapability(...) (*mcp.CallToolResult, error) {
    // Implementation
}

// CRITICAL: Register the adapter
func (c *CapabilityAdapter) Register() {
    api.RegisterCapability(c)
}
```

### 3. Service Usage
Services access functionality ONLY via API:
```go
// In service code
func (s *Service) UseCapability() error {
    handler := api.GetCapability()
    if handler == nil {
        return errors.New("capability API not available")
    }
    
    return handler.ExecuteCapability(ctx, "auth", "login", params)
}
```

### API Pattern Rules
- ‚úÖ **DO**: Define interfaces in `api/handlers.go`
- ‚úÖ **DO**: Create adapters that call `Register()`
- ‚úÖ **DO**: Access via `api.GetXXX()` methods
- ‚úÖ **DO**: Check for nil handlers
- ‚ùå **DON'T**: Import internal packages directly
- ‚ùå **DON'T**: Create circular dependencies
- ‚ùå **DON'T**: Skip the adapter layer
- ‚ùå **Never** introduce direct package coupling
- ‚ùå **Never** use timers or timeouts in tests


## Package Structure

### Core Packages
- `internal/api/` - Handler interfaces and registry
- `internal/aggregator/` - MCP aggregation server
- `internal/capability/` - Capability definitions and loading
- `internal/workflow/` - Workflow execution engine
- `internal/services/` - Service implementations
- `internal/orchestrator/` - Service lifecycle management

### Package Dependencies
```
api (interfaces only)
  ‚Üë
services ‚Üí adapters ‚Üí api.Register()
  ‚Üì
concrete implementations
```

## Capability System Architecture

### Capability Definitions
- **Location**: `internal/capability/definitions/`
- **Format**: YAML with embedded workflows
- **Naming**: `<provider>_<type>.yaml` (e.g., `teleport_auth.yaml`)

Example capability definition:
```yaml
name: teleport_auth
type: auth_provider
description: "Teleport authentication provider"
operations:
  login:
    description: "Authenticate using Teleport"
    requires:
      - x_teleport_kube
      - x_teleport_status
    workflow:
      name: teleport_auth_login
      steps:
        - id: login
          tool: x_teleport_kube
          args:
            cluster: "{{ .cluster }}"
```

### Key Principles
1. **Capabilities are interfaces**, not implementations
2. **Workflows are embedded**, not referenced
3. **Tools have simple names** (e.g., `x_auth_login`)
4. **No "global" registries** - just registries
5. **MCP servers are unaware** of capabilities

## Error Handling

### Standard Error Pattern
```go
if err != nil {
    return fmt.Errorf("operation failed: %w", err)
}
```

### API Error Handling
```go
handler := api.GetSomething()
if handler == nil {
    return errors.New("handler not available")
}
```

## Testing Requirements

### Test Coverage
- **Minimum 80% coverage** for new code
- Unit tests for all public functions
- Integration tests for API interactions
- **Run tests with**: `make test`

### Test Guidelines
- New functionality MUST be covered by appropriate tests
- If fixing a bug, add a test that reproduces the bug
- Update existing tests when behavior changes
- **Never use timers, timeouts, or sleep** in tests (causes flaky tests)

### Test Patterns
```go
func TestFeature(t *testing.T) {
    // Arrange
    adapter := NewAdapter()
    adapter.Register()
    
    // Act
    result, err := api.GetHandler().DoSomething()
    
    // Assert
    require.NoError(t, err)
    assert.Equal(t, expected, result)
}
```

### TUI View Testing
For changes affecting TUI views:
```bash
# Generate/update golden files
NO_COLOR=true go test ./internal/tui/view/... -update

# Review changes in internal/tui/view/testdata/*.golden
# Ensure visual changes are intentional
```

### Running Tests
```bash
# Run all tests
make test

# Run specific package tests
go test ./internal/capability/...

# Run with coverage
go test -cover ./...

# Run with race detection
go test -race ./...
```

## Configuration Management

### Config Loading
- Primary config: `config.yaml`
- Capability definitions: `internal/capability/definitions/`
- No hardcoded paths

### MCP Server Configuration
```yaml
mcpServers:
  - name: teleport
    type: localCommand
    command: ["teleport-mcp"]
    icon: "üîê"
    requiresClusterRole: target
```

## Logging Guidelines

### Use Existing Package
- Enhance `pkg/logging/` - don't create new
- Use structured logging with context
- Include trace IDs for request tracking

Example:
```go
logging.Info("CapabilityLoader", "Loaded %d capabilities", len(capabilities))
logging.Error("CapabilityLoader", "Failed to load capability: %v", err)
```

## Common Anti-Patterns to Avoid

### ‚ùå Direct Package Import
```go
// WRONG
import "envctl/internal/capability"
loader := capability.NewLoader()
```

### ‚úÖ Use API Pattern
```go
// CORRECT
handler := api.GetCapability()
if handler != nil {
    handler.LoadCapabilities()
}
```

### ‚ùå Circular Dependencies
```go
// WRONG: aggregator imports capability which imports aggregator
```

### ‚úÖ One-Way Dependencies
```go
// CORRECT: Both register with API, no direct coupling
```

### ‚ùå Complex Global State
```go
// WRONG
var globalRegistry = &GlobalCapabilityRegistry{}
```

### ‚úÖ Simple Registry
```go
// CORRECT
type Registry struct {
    capabilities map[string]Capability
}
```

## File Organization

### File Length
- Target: ~300 lines per file
- Maximum: 500 lines before splitting
- Check with: `wc -l filename.go`

### Splitting Guidelines
- By functionality: `user.go` ‚Üí `user_auth.go`, `user_profile.go`
- By layer: `service.go` ‚Üí `service_api.go`, `service_logic.go`
- Keep related code together

## Go Development Guidelines

### Package Management
- **Always verify** new packages are latest version
- Use `web_search` to check current versions
- Example: Before `go get github.com/pkg/errors`, search for latest version

### Code Formatting
Before ANY commit:
```bash
# Format imports
goimports -w .

# Format code
go fmt ./...
```

### Code Style
- Follow standard Go conventions
- Use meaningful variable names
- Keep functions focused and small
- Prefer composition over inheritance

## Documentation Requirements

### Code Documentation
- Package-level `doc.go` files
- Function comments for exported functions
- Example usage where helpful

### Updates Required
- Update `docs/` for new features
- Update README.md for API changes
- Document breaking changes in CHANGELOG.md
- Ensure all packages have `doc.go` files
